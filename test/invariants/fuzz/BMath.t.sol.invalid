// SPDX-License-Identifier: UNLICENSED
pragma solidity 0.8.25;

import {EchidnaTest} from '../helpers/AdvancedTestsUtils.sol';

import {BMath} from 'contracts/BMath.sol';

contract FuzzBMath is BMath, EchidnaTest {
  // calcOutGivenIn should be inverse of calcInGivenOut
  function testCalcInGivenOut_InvCalcInGivenOut(
    uint256 tokenBalanceIn,
    uint256 tokenWeightIn,
    uint256 tokenBalanceOut,
    uint256 tokenWeightOut,
    uint256 tokenAmountIn,
    uint256 swapFee
  ) public {
    tokenWeightIn = clamp(tokenWeightIn, MIN_WEIGHT, MAX_WEIGHT);
    tokenWeightOut = clamp(tokenWeightOut, MIN_WEIGHT, MAX_WEIGHT);
    tokenAmountIn = clamp(tokenAmountIn, 1 ether, 10 ether);
    tokenBalanceOut = clamp(tokenBalanceOut, 1 ether, 10 ether);
    tokenBalanceIn = clamp(tokenBalanceIn, 1 ether, 10 ether);
    swapFee = clamp(swapFee, MIN_FEE, MAX_FEE);

    uint256 calc_tokenAmountOut =
      calcOutGivenIn(tokenBalanceIn, tokenWeightIn, tokenBalanceOut, tokenWeightOut, tokenAmountIn, swapFee);

    uint256 calc_tokenAmountIn =
      calcInGivenOut(tokenBalanceOut, tokenWeightOut, tokenBalanceIn, tokenWeightIn, calc_tokenAmountOut, swapFee);

    assert(tokenAmountIn == calc_tokenAmountIn || tokenAmountIn > calc_tokenAmountIn ? tokenAmountIn - calc_tokenAmountIn < BONE : calc_tokenAmountIn - tokenAmountIn < BONE);
  }

  // calcInGivenOut should be inverse of calcOutGivenIn
  function testCalcOutGivenIn_InvCalcOutGivenIn(
    uint256 tokenBalanceIn,
    uint256 tokenWeightIn,
    uint256 tokenBalanceOut,
    uint256 tokenWeightOut,
    uint256 tokenAmountOut,
    uint256 swapFee
  ) public {
    tokenWeightIn = clamp(tokenWeightIn, MIN_WEIGHT, MAX_WEIGHT);
    tokenWeightOut = clamp(tokenWeightOut, MIN_WEIGHT, MAX_WEIGHT);

    uint256 calc_tokenAmountIn =
      calcInGivenOut(tokenBalanceOut, tokenWeightOut, tokenBalanceIn, tokenWeightIn, tokenAmountOut, swapFee);

    uint256 calc_tokenAmountOut =
      calcOutGivenIn(tokenBalanceIn, tokenWeightIn, tokenBalanceOut, tokenWeightOut, calc_tokenAmountIn, swapFee);

    assert(tokenAmountOut == calc_tokenAmountOut);
  }

  // calcSingleInGivenPoolOut should be inverse of calcPoolOutGivenSingleIn
  function testCalcSingleInGivenPoolOut_InvCalcPoolOutGivenSingle(
    uint256 tokenBalanceIn,
    uint256 tokenWeightIn,
    uint256 poolSupply,
    uint256 totalWeight,
    uint256 tokenAmountOut,
    uint256 swapFee
  ) public {
    tokenWeightIn = clamp(tokenWeightIn, MIN_WEIGHT, MAX_WEIGHT);
    totalWeight = clamp(totalWeight, MIN_WEIGHT, MAX_TOTAL_WEIGHT);
    tokenBalanceIn = clamp(tokenBalanceIn, 1, type(uint256).max);

    uint256 calc_tokenAmountIn =
      calcSingleInGivenPoolOut(tokenBalanceIn, tokenWeightIn, poolSupply, totalWeight, tokenAmountOut, swapFee);

    uint256 calc_poolAmountOut =
      calcPoolOutGivenSingleIn(tokenBalanceIn, tokenWeightIn, poolSupply, totalWeight, calc_tokenAmountIn, swapFee);

    assert(tokenAmountOut == calc_poolAmountOut);
  }

  // calcPoolOutGivenSingleIn should be inverse of calcSingleInGivenPoolOut
  function testCalcPoolOutGivenSingle_InvCalcSingleInGivenPoolOut(
    uint256 tokenBalanceIn,
    uint256 tokenWeightIn,
    uint256 poolSupply,
    uint256 totalWeight,
    uint256 poolAmountOut,
    uint256 swapFee
  ) public {
    tokenWeightIn = clamp(tokenWeightIn, MIN_WEIGHT, MAX_WEIGHT);
    totalWeight = clamp(totalWeight, MIN_WEIGHT, MAX_TOTAL_WEIGHT);
    tokenBalanceIn = clamp(tokenBalanceIn, 1, type(uint256).max);

    uint256 calc_poolAmountIn =
      calcPoolOutGivenSingleIn(tokenBalanceIn, tokenWeightIn, poolSupply, totalWeight, poolAmountOut, swapFee);

    uint256 calc_tokenAmountOut =
      calcSingleInGivenPoolOut(tokenBalanceIn, tokenWeightIn, poolSupply, totalWeight, calc_poolAmountIn, swapFee);

    assert(poolAmountOut == calc_tokenAmountOut);
  }
}
