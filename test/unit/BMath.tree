BMathTest::calcSpotPrice
├── when token weight in is zero
│   └── it should revert // division by zero
├── when token balance in too big
│   └── it should revert // bi * BONE > uint256 max
├── when weighted token balance in too big
│   └── it should revert // bi * BONE + (wi / 2) > uint256 max
├── when token weight out is zero
│   └── it should revert // division by zero
├── when token balance out too big
│   └── it should revert // bo * BONE > uint256 max
├── when weighted token balance out too big
│   └── it should revert // bo * BONE + (wo / 2) > uint256 max
├── when weighted token balance out is zero
│   └── it should revert // division by zero
├── when swapFee greater than BONE
│   └── it should revert // subtraction underflow
├── when swapFee equals BONE
│   └── it should revert // division by zero
├── when swap fee is zero
│   └── it should return correct value
│       └── bi/wi * wo/bo
└── when swap fee is non zero
    └── it should return correct value
        └── (bi/wi * wo/bo) * (1 / (1 - sf))

BMathTest::calcOutGivenIn
├── when token weight out is zero
│   └── it should revert // division by zero
├── when token weight in too big
│   └── it should revert // wi * BONE > uint256 max
├── when weighted ratio too big
│   └── it should revert // wi * BONE + (wo / 2) > uint256 max
├── when swapFee greater than BONE
│   └── it should revert // subtraction underflow
├── when swapFee equals BONE
│   └── it should return zero
├── when token amount in too big
│   └── it should revert // ai * (1 - sf) > uint256 max
├── when token balance in and amount in too small
│   └── it should revert // bi + (ai * (1 - swapFee)) = 0
├── when token weight in is zero
│   └── it should return zero
├── when token weights are equal
│   ├── when equal weights and swap fee is zero
│   │   └── it should return correct value
│   │       └── bo * (1 - (bi / (bi + ai))
│   └── when equal weights and swap fee is non zero
│       └── it should return correct value
│           └── bo * (1 - (bi / (bi + (ai * (1-sf))))
└── when token weights are unequal
    ├── when unequal weights and swap fee is zero
    │   └── it should return correct value
    │       └── b0 * (1 - (bi / ((bi + ai)))^(wi/wo))
    └── when unequal weights and swap fee is non zero
        └── it should return correct value
            └── b0 * (1 - (bi / ((bi + (ai * (1 - sf)))))^(wi/wo))

BMathTest::calcInGivenOut
├── when token weight in is zero
│   └── it should revert // division by zero
├── when token weight out too big
│   └── it should revert // wo * BONE > uint256 max
├── when weighted ratio too big
│   └── it should revert // wo * BONE + (wi / 2) > uint256 max
├── when token amount out greater than token balance out
│   └── it should revert // subtraction underflow
├── when token amount out equals token balance out
│   └── it should revert // division by zero
├── when token weight out is zero
│   └── it should return zero
├── when token weights are equal
│   ├── when equal weights and swap fee is zero
│   │   └── it should return correct value
│   │       └── bi * ((bo/(bo-ao) - 1)))
│   └── when equal weights and swap fee is non zero
│       └── it should return correct value
│           └── bi * ((bo/(bo-ao) - 1))) / (1 - sf)
└── when token weights are unequal
    ├── when unequal weights and swap fee is zero
    │   └── it should return correct value
    │       └── bi * (((bo/(bo-ao))^(wo/wi) - 1)))
    └── when unequal weights and swap fee is non zero
        └── it should return correct value
            └── bi * (((bo/(bo-ao))^(wo/wi) - 1))) / (1 - sf)

BMathTest::calcPoolOutGivenSingleIn
├── when token balance in is zero
│   └── it should revert // division by zero
├── when token weight in is zero
│   └── it should return zero
├── when swap fee is zero
│   └── it should return correct value
│       └── ((( ai + bi ) / bi ) ^ (wi/wT)) * pS - pS
└── when swap fee is non zero
    └── it should return correct value
        └── ((( ai * (1 - ((1-(wi/wT))*sf)) + bi) / bi ) ^ (wi/wT)) * pS - pS

BMathTest::calcSingleInGivenPoolOut
├── when total weight is zero
│   └── it should revert // TODO: why
├── when swap fee is zero
│   └── it should revert // TODO: why
└── when using known values
    └── it should return correct value

BMathTest::calcSingleOutGivenPoolIn
├── when pool supply is zero
│   └── it should revert // TODO: why
├── when total weight is zero
│   └── it should revert // TODO: why
├── when token balance out is zero
│   └── it should return zero
└── when using known values
    └── it should return correct value

BMathTest::calcPoolInGivenSingleOut
├── when tokenBalanceOut is zero
│   └── it should revert
├── when swap fee is 1 and token weight out is zero
│   └── it should revert
├── when pool supply is zero
│   └── it should revert
└── when using known values
    └── it should return correct value